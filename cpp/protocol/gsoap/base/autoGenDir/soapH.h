/* soapH.h
   Generated by gSOAP 2.8.43 for autoGenDir/serviceInternal.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef soapH_H
#define soapH_H
#include "soapStub.h"
#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap*, const void*, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap*);
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap*);
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void *SOAP_FMAC4 soap_getelement(struct soap*, int*);
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap*, const void*, const char*, int, int);

#ifdef __cplusplus
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap*);

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap);
SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap*, int, const char*, const char*, size_t*);
SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist*);
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int, int);
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap*, int, int, void*, size_t, const void*, void**);

#ifndef SOAP_TYPE_byte_DEFINED
#define SOAP_TYPE_byte_DEFINED

inline void soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap*, const char*, int, const char *, const char*);
SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap*, const char*, char *, const char*);

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap*, const char *, const char*, const char*);

inline int soap_write_byte(struct soap *soap, char const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_byte(soap, p, "byte", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_byte(soap, p, "byte", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_byte(struct soap *soap, const char *URL, char const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_byte(soap, p, "byte", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap*, char *, const char*, const char*);

inline int soap_read_byte(struct soap *soap, char *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_byte(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_byte(struct soap *soap, const char *URL, char *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_byte(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_byte(struct soap *soap, char *p)
{
	if (soap_read_byte(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_int_DEFINED
#define SOAP_TYPE_int_DEFINED

inline void soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap*, const char*, int, const int *, const char*);
SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap*, const char*, int *, const char*);

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap*, const int *, const char*, const char*);

inline int soap_write_int(struct soap *soap, int const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_int(soap, p, "int", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_int(soap, p, "int", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_int(struct soap *soap, const char *URL, int const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_int(soap, p, "int", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap*, int *, const char*, const char*);

inline int soap_read_int(struct soap *soap, int *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_int(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_int(struct soap *soap, const char *URL, int *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_int(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_int(struct soap *soap, int *p)
{
	if (soap_read_int(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__SendTime_DEFINED
#define SOAP_TYPE_qhjkdsf__SendTime_DEFINED

inline void soap_default_qhjkdsf__SendTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_qhjkdsf__SendTime
	*a = SOAP_DEFAULT_qhjkdsf__SendTime;
#else
	*a = (time_t)0;
#endif
}

#define soap_qhjkdsf__SendTime2s soap_dateTime2s

SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__SendTime(struct soap*, const char*, int, const time_t *, const char*);

#define soap_s2qhjkdsf__SendTime soap_s2dateTime

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_qhjkdsf__SendTime(struct soap*, const char*, time_t *, const char*);

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_qhjkdsf__SendTime(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__SendTime(struct soap*, const time_t *, const char*, const char*);

inline int soap_write_qhjkdsf__SendTime(struct soap *soap, time_t const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__SendTime(soap, p, "qhjkdsf:SendTime", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__SendTime(struct soap *soap, const char *URL, time_t const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__SendTime(soap, p, "qhjkdsf:SendTime", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__SendTime(struct soap *soap, const char *URL, time_t const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__SendTime(soap, p, "qhjkdsf:SendTime", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_qhjkdsf__SendTime(struct soap*, time_t *, const char*, const char*);

inline int soap_read_qhjkdsf__SendTime(struct soap *soap, time_t *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__SendTime(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__SendTime(struct soap *soap, const char *URL, time_t *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__SendTime(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__SendTime(struct soap *soap, time_t *p)
{
	if (soap_read_qhjkdsf__SendTime(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_dateTime_DEFINED
#define SOAP_TYPE_dateTime_DEFINED

inline void soap_default_dateTime(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_dateTime
	*a = SOAP_DEFAULT_dateTime;
#else
	*a = (time_t)0;
#endif
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap*, const char*, int, const time_t *, const char*);
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap*, const char*, time_t *, const char*);

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap*, const time_t *, const char*, const char*);

inline int soap_write_dateTime(struct soap *soap, time_t const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_dateTime(struct soap *soap, const char *URL, time_t const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_dateTime(struct soap *soap, const char *URL, time_t const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_dateTime(soap, p, "dateTime", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap*, time_t *, const char*, const char*);

inline int soap_read_dateTime(struct soap *soap, time_t *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_dateTime(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_dateTime(struct soap *soap, const char *URL, time_t *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_dateTime(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_dateTime(struct soap *soap, time_t *p)
{
	if (soap_read_dateTime(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__MsgBody_DEFINED
#define SOAP_TYPE_qhjkdsf__MsgBody_DEFINED

inline void soap_default_qhjkdsf__MsgBody(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__MsgBody(struct soap*, const std::string *);

#define soap_qhjkdsf__MsgBody2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__MsgBody(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__MsgBody(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__MsgBody(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__MsgBody soap_instantiate_std__string


#define soap_new_qhjkdsf__MsgBody soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__MsgBody(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__MsgBody(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__MsgBody(soap, p, "qhjkdsf:MsgBody", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__MsgBody(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__MsgBody(soap, p, "qhjkdsf:MsgBody", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__MsgBody(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__MsgBody(soap, p, "qhjkdsf:MsgBody", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__MsgBody(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__MsgBody(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__MsgBody(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__MsgBody(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__MsgBody(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__MsgBody(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__MsgBody(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__Signature_DEFINED
#define SOAP_TYPE_qhjkdsf__Signature_DEFINED

inline void soap_default_qhjkdsf__Signature(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__Signature(struct soap*, const std::string *);

#define soap_qhjkdsf__Signature2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__Signature(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__Signature(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__Signature(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__Signature soap_instantiate_std__string


#define soap_new_qhjkdsf__Signature soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__Signature(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__Signature(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__Signature(soap, p, "qhjkdsf:Signature", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__Signature(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__Signature(soap, p, "qhjkdsf:Signature", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__Signature(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__Signature(soap, p, "qhjkdsf:Signature", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__Signature(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__Signature(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__Signature(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__Signature(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__Signature(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__Signature(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__Signature(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__BodyEncrypt_DEFINED
#define SOAP_TYPE_qhjkdsf__BodyEncrypt_DEFINED

inline void soap_default_qhjkdsf__BodyEncrypt(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__BodyEncrypt(struct soap*, const std::string *);

#define soap_qhjkdsf__BodyEncrypt2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__BodyEncrypt(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__BodyEncrypt(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__BodyEncrypt(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__BodyEncrypt soap_instantiate_std__string


#define soap_new_qhjkdsf__BodyEncrypt soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__BodyEncrypt(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__BodyEncrypt(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__BodyEncrypt(soap, p, "qhjkdsf:BodyEncrypt", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__BodyEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__BodyEncrypt(soap, p, "qhjkdsf:BodyEncrypt", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__BodyEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__BodyEncrypt(soap, p, "qhjkdsf:BodyEncrypt", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__BodyEncrypt(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__BodyEncrypt(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__BodyEncrypt(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__BodyEncrypt(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__BodyEncrypt(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__BodyEncrypt(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__BodyEncrypt(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__BodyZip_DEFINED
#define SOAP_TYPE_qhjkdsf__BodyZip_DEFINED

inline void soap_default_qhjkdsf__BodyZip(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__BodyZip(struct soap*, const std::string *);

#define soap_qhjkdsf__BodyZip2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__BodyZip(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__BodyZip(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__BodyZip(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__BodyZip soap_instantiate_std__string


#define soap_new_qhjkdsf__BodyZip soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__BodyZip(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__BodyZip(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__BodyZip(soap, p, "qhjkdsf:BodyZip", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__BodyZip(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__BodyZip(soap, p, "qhjkdsf:BodyZip", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__BodyZip(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__BodyZip(soap, p, "qhjkdsf:BodyZip", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__BodyZip(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__BodyZip(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__BodyZip(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__BodyZip(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__BodyZip(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__BodyZip(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__BodyZip(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__Max127Text_DEFINED
#define SOAP_TYPE_qhjkdsf__Max127Text_DEFINED

inline void soap_default_qhjkdsf__Max127Text(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__Max127Text(struct soap*, const std::string *);

#define soap_qhjkdsf__Max127Text2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__Max127Text(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__Max127Text(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 127, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__Max127Text(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__Max127Text soap_instantiate_std__string


#define soap_new_qhjkdsf__Max127Text soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__Max127Text(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__Max127Text(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__Max127Text(soap, p, "qhjkdsf:Max127Text", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__Max127Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__Max127Text(soap, p, "qhjkdsf:Max127Text", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__Max127Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__Max127Text(soap, p, "qhjkdsf:Max127Text", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__Max127Text(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__Max127Text(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__Max127Text(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__Max127Text(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__Max127Text(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__Max127Text(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__Max127Text(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__GatewayVersion_DEFINED
#define SOAP_TYPE_qhjkdsf__GatewayVersion_DEFINED

inline void soap_default_qhjkdsf__GatewayVersion(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__GatewayVersion(struct soap*, const std::string *);

#define soap_qhjkdsf__GatewayVersion2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__GatewayVersion(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__GatewayVersion(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__GatewayVersion(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__GatewayVersion soap_instantiate_std__string


#define soap_new_qhjkdsf__GatewayVersion soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__GatewayVersion(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__GatewayVersion(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__GatewayVersion(soap, p, "qhjkdsf:GatewayVersion", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__GatewayVersion(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__GatewayVersion(soap, p, "qhjkdsf:GatewayVersion", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__GatewayVersion(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__GatewayVersion(soap, p, "qhjkdsf:GatewayVersion", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__GatewayVersion(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__GatewayVersion(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__GatewayVersion(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__GatewayVersion(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__GatewayVersion(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__GatewayVersion(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__GatewayVersion(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__ReturnEncrypt_DEFINED
#define SOAP_TYPE_qhjkdsf__ReturnEncrypt_DEFINED

inline void soap_default_qhjkdsf__ReturnEncrypt(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__ReturnEncrypt(struct soap*, const std::string *);

#define soap_qhjkdsf__ReturnEncrypt2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__ReturnEncrypt(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__ReturnEncrypt(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__ReturnEncrypt(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__ReturnEncrypt soap_instantiate_std__string


#define soap_new_qhjkdsf__ReturnEncrypt soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__ReturnEncrypt(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__ReturnEncrypt(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__ReturnEncrypt(soap, p, "qhjkdsf:ReturnEncrypt", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__ReturnEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__ReturnEncrypt(soap, p, "qhjkdsf:ReturnEncrypt", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__ReturnEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__ReturnEncrypt(soap, p, "qhjkdsf:ReturnEncrypt", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__ReturnEncrypt(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__ReturnEncrypt(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__ReturnEncrypt(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__ReturnEncrypt(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__ReturnEncrypt(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__ReturnEncrypt(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__ReturnEncrypt(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__ZipType_DEFINED
#define SOAP_TYPE_qhjkdsf__ZipType_DEFINED

inline void soap_default_qhjkdsf__ZipType(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__ZipType(struct soap*, const std::string *);

#define soap_qhjkdsf__ZipType2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__ZipType(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__ZipType(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__ZipType(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__ZipType soap_instantiate_std__string


#define soap_new_qhjkdsf__ZipType soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__ZipType(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__ZipType(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__ZipType(soap, p, "qhjkdsf:ZipType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__ZipType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__ZipType(soap, p, "qhjkdsf:ZipType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__ZipType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__ZipType(soap, p, "qhjkdsf:ZipType", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__ZipType(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__ZipType(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__ZipType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__ZipType(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__ZipType(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__ZipType(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__ZipType(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__Resptype_DEFINED
#define SOAP_TYPE_qhjkdsf__Resptype_DEFINED

inline void soap_default_qhjkdsf__Resptype(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__Resptype(struct soap*, const std::string *);

#define soap_qhjkdsf__Resptype2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__Resptype(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__Resptype(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__Resptype(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__Resptype soap_instantiate_std__string


#define soap_new_qhjkdsf__Resptype soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__Resptype(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__Resptype(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__Resptype(soap, p, "qhjkdsf:Resptype", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__Resptype(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__Resptype(soap, p, "qhjkdsf:Resptype", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__Resptype(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__Resptype(soap, p, "qhjkdsf:Resptype", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__Resptype(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__Resptype(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__Resptype(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__Resptype(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__Resptype(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__Resptype(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__Resptype(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__Max14NumericText_DEFINED
#define SOAP_TYPE_qhjkdsf__Max14NumericText_DEFINED

inline void soap_default_qhjkdsf__Max14NumericText(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__Max14NumericText(struct soap*, const std::string *);

#define soap_qhjkdsf__Max14NumericText2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__Max14NumericText(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__Max14NumericText(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__Max14NumericText(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__Max14NumericText soap_instantiate_std__string


#define soap_new_qhjkdsf__Max14NumericText soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__Max14NumericText(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__Max14NumericText(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__Max14NumericText(soap, p, "qhjkdsf:Max14NumericText", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__Max14NumericText(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__Max14NumericText(soap, p, "qhjkdsf:Max14NumericText", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__Max14NumericText(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__Max14NumericText(soap, p, "qhjkdsf:Max14NumericText", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__Max14NumericText(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__Max14NumericText(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__Max14NumericText(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__Max14NumericText(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__Max14NumericText(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__Max14NumericText(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__Max14NumericText(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif
/* qhjkdsf__Version is a typedef synonym for xsd__decimal */

#ifndef SOAP_TYPE_qhjkdsf__Version_DEFINED
#define SOAP_TYPE_qhjkdsf__Version_DEFINED

#define soap_default_qhjkdsf__Version soap_default_xsd__decimal


#define soap_serialize_qhjkdsf__Version soap_serialize_xsd__decimal


#define soap_qhjkdsf__Version2s(soap, a) ((a).c_str())

#define soap_out_qhjkdsf__Version soap_out_xsd__decimal


#define soap_s2qhjkdsf__Version(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)

#define soap_in_qhjkdsf__Version soap_in_xsd__decimal


#define soap_instantiate_qhjkdsf__Version soap_instantiate_xsd__decimal


#define soap_new_qhjkdsf__Version soap_new_xsd__decimal


#define soap_put_qhjkdsf__Version soap_put_xsd__decimal


#define soap_write_qhjkdsf__Version soap_write_xsd__decimal


#define soap_PUT_qhjkdsf__Version soap_PUT_xsd__decimal


#define soap_POST_send_qhjkdsf__Version soap_POST_send_xsd__decimal


#define soap_get_qhjkdsf__Version soap_get_xsd__decimal


#define soap_read_qhjkdsf__Version soap_read_xsd__decimal


#define soap_GET_qhjkdsf__Version soap_GET_xsd__decimal


#define soap_POST_recv_qhjkdsf__Version soap_POST_recv_xsd__decimal

#endif

#ifndef SOAP_TYPE_qhjkdsf__Max20Text_DEFINED
#define SOAP_TYPE_qhjkdsf__Max20Text_DEFINED

inline void soap_default_qhjkdsf__Max20Text(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_qhjkdsf__Max20Text(struct soap*, const std::string *);

#define soap_qhjkdsf__Max20Text2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__Max20Text(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2qhjkdsf__Max20Text(soap, s, a) soap_s2stdchar((soap), (s), (a), 1, 20, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_qhjkdsf__Max20Text(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_qhjkdsf__Max20Text soap_instantiate_std__string


#define soap_new_qhjkdsf__Max20Text soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_qhjkdsf__Max20Text(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_qhjkdsf__Max20Text(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_qhjkdsf__Max20Text(soap, p, "qhjkdsf:Max20Text", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__Max20Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_qhjkdsf__Max20Text(soap, p, "qhjkdsf:Max20Text", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__Max20Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_qhjkdsf__Max20Text(soap, p, "qhjkdsf:Max20Text", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_qhjkdsf__Max20Text(struct soap*, std::string *, const char*, const char*);

inline int soap_read_qhjkdsf__Max20Text(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_qhjkdsf__Max20Text(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__Max20Text(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__Max20Text(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__Max20Text(struct soap *soap, std::string *p)
{
	if (soap_read_qhjkdsf__Max20Text(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__responseBody_DEFINED
#define SOAP_TYPE_qhjkdsf__responseBody_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__responseBody(struct soap*, const char*, int, const qhjkdsf__responseBody *, const char*);
SOAP_FMAC3 qhjkdsf__responseBody * SOAP_FMAC4 soap_in_qhjkdsf__responseBody(struct soap*, const char*, qhjkdsf__responseBody *, const char*);
SOAP_FMAC1 qhjkdsf__responseBody * SOAP_FMAC2 soap_instantiate_qhjkdsf__responseBody(struct soap*, int, const char*, const char*, size_t*);

inline qhjkdsf__responseBody * soap_new_qhjkdsf__responseBody(struct soap *soap, int n = -1)
{
	return soap_instantiate_qhjkdsf__responseBody(soap, n, NULL, NULL, NULL);
}

inline qhjkdsf__responseBody * soap_new_req_qhjkdsf__responseBody(
	struct soap *soap,
	const std::string& bodyzip,
	const std::string& bodyencrypt,
	const std::string& signature,
	const std::string& msgbody)
{
	qhjkdsf__responseBody *_p = soap_new_qhjkdsf__responseBody(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->qhjkdsf__responseBody::bodyzip = bodyzip;
		_p->qhjkdsf__responseBody::bodyencrypt = bodyencrypt;
		_p->qhjkdsf__responseBody::signature = signature;
		_p->qhjkdsf__responseBody::msgbody = msgbody;
	}
	return _p;
}

inline qhjkdsf__responseBody * soap_new_set_qhjkdsf__responseBody(
	struct soap *soap,
	const std::string& bodyzip,
	const std::string& bodyencrypt,
	const std::string& signature,
	const std::string& msgbody)
{
	qhjkdsf__responseBody *_p = soap_new_qhjkdsf__responseBody(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->qhjkdsf__responseBody::bodyzip = bodyzip;
		_p->qhjkdsf__responseBody::bodyencrypt = bodyencrypt;
		_p->qhjkdsf__responseBody::signature = signature;
		_p->qhjkdsf__responseBody::msgbody = msgbody;
	}
	return _p;
}

inline int soap_write_qhjkdsf__responseBody(struct soap *soap, qhjkdsf__responseBody const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "qhjkdsf:responseBody", p->soap_type() == SOAP_TYPE_qhjkdsf__responseBody ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__responseBody(struct soap *soap, const char *URL, qhjkdsf__responseBody const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "qhjkdsf:responseBody", p->soap_type() == SOAP_TYPE_qhjkdsf__responseBody ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__responseBody(struct soap *soap, const char *URL, qhjkdsf__responseBody const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "qhjkdsf:responseBody", p->soap_type() == SOAP_TYPE_qhjkdsf__responseBody ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 qhjkdsf__responseBody * SOAP_FMAC4 soap_get_qhjkdsf__responseBody(struct soap*, qhjkdsf__responseBody *, const char*, const char*);

inline int soap_read_qhjkdsf__responseBody(struct soap *soap, qhjkdsf__responseBody *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_qhjkdsf__responseBody(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__responseBody(struct soap *soap, const char *URL, qhjkdsf__responseBody *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__responseBody(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__responseBody(struct soap *soap, qhjkdsf__responseBody *p)
{
	if (soap_read_qhjkdsf__responseBody(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_qhjkdsf__requestBody_DEFINED
#define SOAP_TYPE_qhjkdsf__requestBody_DEFINED
SOAP_FMAC3 int SOAP_FMAC4 soap_out_qhjkdsf__requestBody(struct soap*, const char*, int, const qhjkdsf__requestBody *, const char*);
SOAP_FMAC3 qhjkdsf__requestBody * SOAP_FMAC4 soap_in_qhjkdsf__requestBody(struct soap*, const char*, qhjkdsf__requestBody *, const char*);
SOAP_FMAC1 qhjkdsf__requestBody * SOAP_FMAC2 soap_instantiate_qhjkdsf__requestBody(struct soap*, int, const char*, const char*, size_t*);

inline qhjkdsf__requestBody * soap_new_qhjkdsf__requestBody(struct soap *soap, int n = -1)
{
	return soap_instantiate_qhjkdsf__requestBody(soap, n, NULL, NULL, NULL);
}

inline qhjkdsf__requestBody * soap_new_req_qhjkdsf__requestBody(
	struct soap *soap,
	const std::string& msgtype,
	const std::string& version,
	const std::string& subnode,
	const std::string& sendtime,
	const std::string& msgno,
	const std::string& resptype,
	const std::string& ziptype,
	const std::string& gatewayversion,
	const std::string& signature,
	const std::string& msgbody)
{
	qhjkdsf__requestBody *_p = soap_new_qhjkdsf__requestBody(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->qhjkdsf__requestBody::msgtype = msgtype;
		_p->qhjkdsf__requestBody::version = version;
		_p->qhjkdsf__requestBody::subnode = subnode;
		_p->qhjkdsf__requestBody::sendtime = sendtime;
		_p->qhjkdsf__requestBody::msgno = msgno;
		_p->qhjkdsf__requestBody::resptype = resptype;
		_p->qhjkdsf__requestBody::ziptype = ziptype;
		_p->qhjkdsf__requestBody::gatewayversion = gatewayversion;
		_p->qhjkdsf__requestBody::signature = signature;
		_p->qhjkdsf__requestBody::msgbody = msgbody;
	}
	return _p;
}

inline qhjkdsf__requestBody * soap_new_set_qhjkdsf__requestBody(
	struct soap *soap,
	const std::string& msgtype,
	const std::string& version,
	const std::string& subnode,
	const std::string& sendtime,
	const std::string& msgno,
	const std::string& resptype,
	const std::string& ziptype,
	std::string *returnencrypt,
	const std::string& gatewayversion,
	std::string *respurl,
	const std::string& signature,
	const std::string& msgbody)
{
	qhjkdsf__requestBody *_p = soap_new_qhjkdsf__requestBody(soap);
	if (_p)
	{	_p->soap_default(soap);
		_p->qhjkdsf__requestBody::msgtype = msgtype;
		_p->qhjkdsf__requestBody::version = version;
		_p->qhjkdsf__requestBody::subnode = subnode;
		_p->qhjkdsf__requestBody::sendtime = sendtime;
		_p->qhjkdsf__requestBody::msgno = msgno;
		_p->qhjkdsf__requestBody::resptype = resptype;
		_p->qhjkdsf__requestBody::ziptype = ziptype;
		_p->qhjkdsf__requestBody::returnencrypt = returnencrypt;
		_p->qhjkdsf__requestBody::gatewayversion = gatewayversion;
		_p->qhjkdsf__requestBody::respurl = respurl;
		_p->qhjkdsf__requestBody::signature = signature;
		_p->qhjkdsf__requestBody::msgbody = msgbody;
	}
	return _p;
}

inline int soap_write_qhjkdsf__requestBody(struct soap *soap, qhjkdsf__requestBody const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "qhjkdsf:requestBody", p->soap_type() == SOAP_TYPE_qhjkdsf__requestBody ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_qhjkdsf__requestBody(struct soap *soap, const char *URL, qhjkdsf__requestBody const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "qhjkdsf:requestBody", p->soap_type() == SOAP_TYPE_qhjkdsf__requestBody ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_qhjkdsf__requestBody(struct soap *soap, const char *URL, qhjkdsf__requestBody const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (p->soap_serialize(soap), 0) || p->soap_put(soap, "qhjkdsf:requestBody", p->soap_type() == SOAP_TYPE_qhjkdsf__requestBody ? "" : NULL) || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 qhjkdsf__requestBody * SOAP_FMAC4 soap_get_qhjkdsf__requestBody(struct soap*, qhjkdsf__requestBody *, const char*, const char*);

inline int soap_read_qhjkdsf__requestBody(struct soap *soap, qhjkdsf__requestBody *p)
{
	if (p)
	{	p->soap_default(soap);
		if (soap_begin_recv(soap) || soap_get_qhjkdsf__requestBody(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_qhjkdsf__requestBody(struct soap *soap, const char *URL, qhjkdsf__requestBody *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_qhjkdsf__requestBody(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_qhjkdsf__requestBody(struct soap *soap, qhjkdsf__requestBody *p)
{
	if (soap_read_qhjkdsf__requestBody(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__decimal_DEFINED
#define SOAP_TYPE_xsd__decimal_DEFINED

inline void soap_default_xsd__decimal(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__decimal(struct soap*, const std::string *);

#define soap_xsd__decimal2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__decimal(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__decimal(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__decimal(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__decimal soap_instantiate_std__string


#define soap_new_xsd__decimal soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__decimal(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__decimal(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__decimal(soap, p, "xsd:decimal", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__decimal(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__decimal(soap, p, "xsd:decimal", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__decimal(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__decimal(soap, p, "xsd:decimal", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__decimal(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__decimal(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__decimal(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__decimal(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__decimal(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__decimal(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__decimal(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__ZipType_DEFINED
#define SOAP_TYPE_xsd__ZipType_DEFINED

inline void soap_default_xsd__ZipType(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ZipType(struct soap*, const std::string *);

#define soap_xsd__ZipType2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ZipType(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__ZipType(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ZipType(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__ZipType soap_instantiate_std__string


#define soap_new_xsd__ZipType soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ZipType(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__ZipType(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__ZipType(soap, p, "xsd:ZipType", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__ZipType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__ZipType(soap, p, "xsd:ZipType", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__ZipType(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__ZipType(soap, p, "xsd:ZipType", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ZipType(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__ZipType(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__ZipType(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__ZipType(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__ZipType(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__ZipType(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__ZipType(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__Version_DEFINED
#define SOAP_TYPE_xsd__Version_DEFINED

inline void soap_default_xsd__Version(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__Version(struct soap*, const std::string *);

#define soap_xsd__Version2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__Version(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__Version(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__Version(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__Version soap_instantiate_std__string


#define soap_new_xsd__Version soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Version(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__Version(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__Version(soap, p, "xsd:Version", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__Version(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__Version(soap, p, "xsd:Version", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__Version(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__Version(soap, p, "xsd:Version", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__Version(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__Version(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__Version(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__Version(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__Version(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__Version(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__Version(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__Signature_DEFINED
#define SOAP_TYPE_xsd__Signature_DEFINED

inline void soap_default_xsd__Signature(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__Signature(struct soap*, const std::string *);

#define soap_xsd__Signature2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__Signature(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__Signature(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__Signature(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__Signature soap_instantiate_std__string


#define soap_new_xsd__Signature soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Signature(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__Signature(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__Signature(soap, p, "xsd:Signature", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__Signature(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__Signature(soap, p, "xsd:Signature", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__Signature(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__Signature(soap, p, "xsd:Signature", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__Signature(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__Signature(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__Signature(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__Signature(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__Signature(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__Signature(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__Signature(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__SendTime_DEFINED
#define SOAP_TYPE_xsd__SendTime_DEFINED

inline void soap_default_xsd__SendTime(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__SendTime(struct soap*, const std::string *);

#define soap_xsd__SendTime2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__SendTime(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__SendTime(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__SendTime(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__SendTime soap_instantiate_std__string


#define soap_new_xsd__SendTime soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__SendTime(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__SendTime(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__SendTime(soap, p, "xsd:SendTime", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__SendTime(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__SendTime(soap, p, "xsd:SendTime", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__SendTime(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__SendTime(soap, p, "xsd:SendTime", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__SendTime(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__SendTime(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__SendTime(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__SendTime(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__SendTime(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__SendTime(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__SendTime(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__ReturnEncrypt_DEFINED
#define SOAP_TYPE_xsd__ReturnEncrypt_DEFINED

inline void soap_default_xsd__ReturnEncrypt(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__ReturnEncrypt(struct soap*, const std::string *);

#define soap_xsd__ReturnEncrypt2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__ReturnEncrypt(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__ReturnEncrypt(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__ReturnEncrypt(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__ReturnEncrypt soap_instantiate_std__string


#define soap_new_xsd__ReturnEncrypt soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__ReturnEncrypt(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__ReturnEncrypt(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__ReturnEncrypt(soap, p, "xsd:ReturnEncrypt", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__ReturnEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__ReturnEncrypt(soap, p, "xsd:ReturnEncrypt", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__ReturnEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__ReturnEncrypt(soap, p, "xsd:ReturnEncrypt", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__ReturnEncrypt(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__ReturnEncrypt(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__ReturnEncrypt(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__ReturnEncrypt(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__ReturnEncrypt(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__ReturnEncrypt(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__ReturnEncrypt(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__Resptype_DEFINED
#define SOAP_TYPE_xsd__Resptype_DEFINED

inline void soap_default_xsd__Resptype(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__Resptype(struct soap*, const std::string *);

#define soap_xsd__Resptype2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__Resptype(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__Resptype(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__Resptype(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__Resptype soap_instantiate_std__string


#define soap_new_xsd__Resptype soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Resptype(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__Resptype(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__Resptype(soap, p, "xsd:Resptype", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__Resptype(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__Resptype(soap, p, "xsd:Resptype", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__Resptype(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__Resptype(soap, p, "xsd:Resptype", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__Resptype(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__Resptype(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__Resptype(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__Resptype(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__Resptype(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__Resptype(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__Resptype(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__MsgBody_DEFINED
#define SOAP_TYPE_xsd__MsgBody_DEFINED

inline void soap_default_xsd__MsgBody(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__MsgBody(struct soap*, const std::string *);

#define soap_xsd__MsgBody2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__MsgBody(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__MsgBody(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__MsgBody(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__MsgBody soap_instantiate_std__string


#define soap_new_xsd__MsgBody soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__MsgBody(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__MsgBody(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__MsgBody(soap, p, "xsd:MsgBody", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__MsgBody(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__MsgBody(soap, p, "xsd:MsgBody", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__MsgBody(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__MsgBody(soap, p, "xsd:MsgBody", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__MsgBody(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__MsgBody(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__MsgBody(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__MsgBody(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__MsgBody(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__MsgBody(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__MsgBody(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__Max20Text_DEFINED
#define SOAP_TYPE_xsd__Max20Text_DEFINED

inline void soap_default_xsd__Max20Text(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__Max20Text(struct soap*, const std::string *);

#define soap_xsd__Max20Text2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__Max20Text(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__Max20Text(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__Max20Text(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__Max20Text soap_instantiate_std__string


#define soap_new_xsd__Max20Text soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Max20Text(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__Max20Text(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__Max20Text(soap, p, "xsd:Max20Text", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__Max20Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__Max20Text(soap, p, "xsd:Max20Text", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__Max20Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__Max20Text(soap, p, "xsd:Max20Text", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__Max20Text(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__Max20Text(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__Max20Text(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__Max20Text(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__Max20Text(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__Max20Text(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__Max20Text(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__Max14NumericText_DEFINED
#define SOAP_TYPE_xsd__Max14NumericText_DEFINED

inline void soap_default_xsd__Max14NumericText(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__Max14NumericText(struct soap*, const std::string *);

#define soap_xsd__Max14NumericText2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__Max14NumericText(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__Max14NumericText(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__Max14NumericText(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__Max14NumericText soap_instantiate_std__string


#define soap_new_xsd__Max14NumericText soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Max14NumericText(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__Max14NumericText(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__Max14NumericText(soap, p, "xsd:Max14NumericText", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__Max14NumericText(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__Max14NumericText(soap, p, "xsd:Max14NumericText", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__Max14NumericText(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__Max14NumericText(soap, p, "xsd:Max14NumericText", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__Max14NumericText(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__Max14NumericText(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__Max14NumericText(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__Max14NumericText(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__Max14NumericText(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__Max14NumericText(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__Max14NumericText(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__Max127Text_DEFINED
#define SOAP_TYPE_xsd__Max127Text_DEFINED

inline void soap_default_xsd__Max127Text(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__Max127Text(struct soap*, const std::string *);

#define soap_xsd__Max127Text2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__Max127Text(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__Max127Text(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__Max127Text(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__Max127Text soap_instantiate_std__string


#define soap_new_xsd__Max127Text soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__Max127Text(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__Max127Text(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__Max127Text(soap, p, "xsd:Max127Text", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__Max127Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__Max127Text(soap, p, "xsd:Max127Text", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__Max127Text(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__Max127Text(soap, p, "xsd:Max127Text", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__Max127Text(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__Max127Text(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__Max127Text(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__Max127Text(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__Max127Text(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__Max127Text(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__Max127Text(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__GatewayVersion_DEFINED
#define SOAP_TYPE_xsd__GatewayVersion_DEFINED

inline void soap_default_xsd__GatewayVersion(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__GatewayVersion(struct soap*, const std::string *);

#define soap_xsd__GatewayVersion2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__GatewayVersion(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__GatewayVersion(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__GatewayVersion(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__GatewayVersion soap_instantiate_std__string


#define soap_new_xsd__GatewayVersion soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__GatewayVersion(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__GatewayVersion(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__GatewayVersion(soap, p, "xsd:GatewayVersion", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__GatewayVersion(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__GatewayVersion(soap, p, "xsd:GatewayVersion", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__GatewayVersion(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__GatewayVersion(soap, p, "xsd:GatewayVersion", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__GatewayVersion(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__GatewayVersion(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__GatewayVersion(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__GatewayVersion(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__GatewayVersion(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__GatewayVersion(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__GatewayVersion(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__BodyZip_DEFINED
#define SOAP_TYPE_xsd__BodyZip_DEFINED

inline void soap_default_xsd__BodyZip(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__BodyZip(struct soap*, const std::string *);

#define soap_xsd__BodyZip2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__BodyZip(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__BodyZip(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__BodyZip(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__BodyZip soap_instantiate_std__string


#define soap_new_xsd__BodyZip soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__BodyZip(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__BodyZip(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__BodyZip(soap, p, "xsd:BodyZip", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__BodyZip(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__BodyZip(soap, p, "xsd:BodyZip", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__BodyZip(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__BodyZip(soap, p, "xsd:BodyZip", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__BodyZip(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__BodyZip(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__BodyZip(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__BodyZip(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__BodyZip(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__BodyZip(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__BodyZip(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_xsd__BodyEncrypt_DEFINED
#define SOAP_TYPE_xsd__BodyEncrypt_DEFINED

inline void soap_default_xsd__BodyEncrypt(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__BodyEncrypt(struct soap*, const std::string *);

#define soap_xsd__BodyEncrypt2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__BodyEncrypt(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2xsd__BodyEncrypt(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__BodyEncrypt(struct soap*, const char*, std::string*, const char*);

#define soap_instantiate_xsd__BodyEncrypt soap_instantiate_std__string


#define soap_new_xsd__BodyEncrypt soap_new_std__string

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__BodyEncrypt(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_xsd__BodyEncrypt(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_xsd__BodyEncrypt(soap, p, "xsd:BodyEncrypt", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_xsd__BodyEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_xsd__BodyEncrypt(soap, p, "xsd:BodyEncrypt", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_xsd__BodyEncrypt(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_xsd__BodyEncrypt(soap, p, "xsd:BodyEncrypt", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__BodyEncrypt(struct soap*, std::string *, const char*, const char*);

inline int soap_read_xsd__BodyEncrypt(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_xsd__BodyEncrypt(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_xsd__BodyEncrypt(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_xsd__BodyEncrypt(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_xsd__BodyEncrypt(struct soap *soap, std::string *p)
{
	if (soap_read_xsd__BodyEncrypt(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_std__string_DEFINED
#define SOAP_TYPE_std__string_DEFINED

inline void soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap*, const std::string *);

#define soap_std__string2s(soap, a) ((a).c_str())
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap*, const char*, int, const std::string*, const char*);

#define soap_s2std__string(soap, s, a) soap_s2stdchar((soap), (s), (a), 0, -1, NULL)
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap*, const char*, std::string*, const char*);
SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap*, int, const char*, const char*, size_t*);

inline std::string * soap_new_std__string(struct soap *soap, int n = -1)
{
	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

inline std::string * soap_new_req_std__string(
	struct soap *soap)
{
	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}

inline std::string * soap_new_set_std__string(
	struct soap *soap)
{
	std::string *_p = soap_new_std__string(soap);
	if (_p)
	{	soap_default_std__string(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap*, const std::string *, const char*, const char*);

inline int soap_write_std__string(struct soap *soap, std::string const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_std__string(soap, p, "string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_std__string(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_std__string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_std__string(struct soap *soap, const char *URL, std::string const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_std__string(soap, p, "string", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap*, std::string *, const char*, const char*);

inline int soap_read_std__string(struct soap *soap, std::string *p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_std__string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_std__string(struct soap *soap, const char *URL, std::string *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_std__string(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_std__string(struct soap *soap, std::string *p)
{
	if (soap_read_std__string(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault_DEFINED
#define SOAP_TYPE_SOAP_ENV__Fault_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap*, const char*, int, const struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap*, const char*, struct SOAP_ENV__Fault *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Fault * soap_new_SOAP_ENV__Fault(struct soap *soap, int n = -1)
{
	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Fault * soap_new_req_SOAP_ENV__Fault(
	struct soap *soap)
{
	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Fault * soap_new_set_SOAP_ENV__Fault(
	struct soap *soap,
	char *faultcode,
	char *faultstring,
	char *faultactor,
	struct SOAP_ENV__Detail *detail,
	struct SOAP_ENV__Code *SOAP_ENV__Code,
	struct SOAP_ENV__Reason *SOAP_ENV__Reason,
	char *SOAP_ENV__Node,
	char *SOAP_ENV__Role,
	struct SOAP_ENV__Detail *SOAP_ENV__Detail)
{
	struct SOAP_ENV__Fault *_p = soap_new_SOAP_ENV__Fault(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Fault(soap, _p);
		_p->faultcode = faultcode;
		_p->faultstring = faultstring;
		_p->faultactor = faultactor;
		_p->detail = detail;
		_p->SOAP_ENV__Code = SOAP_ENV__Code;
		_p->SOAP_ENV__Reason = SOAP_ENV__Reason;
		_p->SOAP_ENV__Node = SOAP_ENV__Node;
		_p->SOAP_ENV__Role = SOAP_ENV__Role;
		_p->SOAP_ENV__Detail = SOAP_ENV__Detail;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap*, const struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_write_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Fault(soap, p), 0) || soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (soap_serialize_SOAP_ENV__Fault(soap, p), 0) || soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || (soap_serialize_SOAP_ENV__Fault(soap, p), 0) || soap_put_SOAP_ENV__Fault(soap, p, "SOAP-ENV:Fault", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap*, struct SOAP_ENV__Fault *, const char*, const char*);

inline int soap_read_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Fault(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Fault(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Fault(struct soap *soap, const char *URL, struct SOAP_ENV__Fault *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_SOAP_ENV__Fault(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{
	if (soap_read_SOAP_ENV__Fault(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_SOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap*, const char*, int, const struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Reason * soap_new_SOAP_ENV__Reason(struct soap *soap, int n = -1)
{
	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Reason * soap_new_req_SOAP_ENV__Reason(
	struct soap *soap)
{
	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Reason * soap_new_set_SOAP_ENV__Reason(
	struct soap *soap,
	char *SOAP_ENV__Text)
{
	struct SOAP_ENV__Reason *_p = soap_new_SOAP_ENV__Reason(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Reason(soap, _p);
		_p->SOAP_ENV__Text = SOAP_ENV__Text;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap*, const struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_write_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Reason(soap, p), 0) || soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (soap_serialize_SOAP_ENV__Reason(soap, p), 0) || soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || (soap_serialize_SOAP_ENV__Reason(soap, p), 0) || soap_put_SOAP_ENV__Reason(soap, p, "SOAP-ENV:Reason", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *, const char*, const char*);

inline int soap_read_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Reason(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Reason(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Reason(struct soap *soap, const char *URL, struct SOAP_ENV__Reason *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_SOAP_ENV__Reason(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{
	if (soap_read_SOAP_ENV__Reason(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_SOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap*, const char*, int, const struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Detail * soap_new_SOAP_ENV__Detail(struct soap *soap, int n = -1)
{
	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Detail * soap_new_req_SOAP_ENV__Detail(
	struct soap *soap,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}

inline struct SOAP_ENV__Detail * soap_new_set_SOAP_ENV__Detail(
	struct soap *soap,
	char *__any,
	int __type,
	void *fault)
{
	struct SOAP_ENV__Detail *_p = soap_new_SOAP_ENV__Detail(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Detail(soap, _p);
		_p->__any = __any;
		_p->__type = __type;
		_p->fault = fault;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap*, const struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_write_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Detail(soap, p), 0) || soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (soap_serialize_SOAP_ENV__Detail(soap, p), 0) || soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || (soap_serialize_SOAP_ENV__Detail(soap, p), 0) || soap_put_SOAP_ENV__Detail(soap, p, "SOAP-ENV:Detail", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *, const char*, const char*);

inline int soap_read_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Detail(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Detail(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Detail(struct soap *soap, const char *URL, struct SOAP_ENV__Detail *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_SOAP_ENV__Detail(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{
	if (soap_read_SOAP_ENV__Detail(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code_DEFINED
#define SOAP_TYPE_SOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap*, const char*, int, const struct SOAP_ENV__Code *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Code * soap_new_SOAP_ENV__Code(struct soap *soap, int n = -1)
{
	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Code * soap_new_req_SOAP_ENV__Code(
	struct soap *soap)
{
	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Code * soap_new_set_SOAP_ENV__Code(
	struct soap *soap,
	char *SOAP_ENV__Value,
	struct SOAP_ENV__Code *SOAP_ENV__Subcode)
{
	struct SOAP_ENV__Code *_p = soap_new_SOAP_ENV__Code(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Code(soap, _p);
		_p->SOAP_ENV__Value = SOAP_ENV__Value;
		_p->SOAP_ENV__Subcode = SOAP_ENV__Subcode;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap*, const struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_write_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Code(soap, p), 0) || soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (soap_serialize_SOAP_ENV__Code(soap, p), 0) || soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || (soap_serialize_SOAP_ENV__Code(soap, p), 0) || soap_put_SOAP_ENV__Code(soap, p, "SOAP-ENV:Code", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *, const char*, const char*);

inline int soap_read_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Code(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Code(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Code(struct soap *soap, const char *URL, struct SOAP_ENV__Code *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_SOAP_ENV__Code(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{
	if (soap_read_SOAP_ENV__Code(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header_DEFINED
#define SOAP_TYPE_SOAP_ENV__Header_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap*, const char*, int, const struct SOAP_ENV__Header *, const char*);
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap*, const char*, struct SOAP_ENV__Header *, const char*);
SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);

inline struct SOAP_ENV__Header * soap_new_SOAP_ENV__Header(struct soap *soap, int n = -1)
{
	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

inline struct SOAP_ENV__Header * soap_new_req_SOAP_ENV__Header(
	struct soap *soap)
{
	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}

inline struct SOAP_ENV__Header * soap_new_set_SOAP_ENV__Header(
	struct soap *soap)
{
	struct SOAP_ENV__Header *_p = soap_new_SOAP_ENV__Header(soap);
	if (_p)
	{	soap_default_SOAP_ENV__Header(soap, _p);
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap*, const struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_write_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (soap_serialize_SOAP_ENV__Header(soap, p), 0) || soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (soap_serialize_SOAP_ENV__Header(soap, p), 0) || soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || (soap_serialize_SOAP_ENV__Header(soap, p), 0) || soap_put_SOAP_ENV__Header(soap, p, "SOAP-ENV:Header", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap*, struct SOAP_ENV__Header *, const char*, const char*);

inline int soap_read_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
	if (p)
	{	soap_default_SOAP_ENV__Header(soap, p);
		if (soap_begin_recv(soap) || soap_get_SOAP_ENV__Header(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_SOAP_ENV__Header(struct soap *soap, const char *URL, struct SOAP_ENV__Header *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_SOAP_ENV__Header(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{
	if (soap_read_SOAP_ENV__Header(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#endif

#ifndef SOAP_TYPE___qhjkdsf__dsf_DEFINED
#define SOAP_TYPE___qhjkdsf__dsf_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_default___qhjkdsf__dsf(struct soap*, struct __qhjkdsf__dsf *);
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___qhjkdsf__dsf(struct soap*, const struct __qhjkdsf__dsf *);
SOAP_FMAC3 int SOAP_FMAC4 soap_out___qhjkdsf__dsf(struct soap*, const char*, int, const struct __qhjkdsf__dsf *, const char*);
SOAP_FMAC3 struct __qhjkdsf__dsf * SOAP_FMAC4 soap_in___qhjkdsf__dsf(struct soap*, const char*, struct __qhjkdsf__dsf *, const char*);
SOAP_FMAC1 struct __qhjkdsf__dsf * SOAP_FMAC2 soap_instantiate___qhjkdsf__dsf(struct soap*, int, const char*, const char*, size_t*);

inline struct __qhjkdsf__dsf * soap_new___qhjkdsf__dsf(struct soap *soap, int n = -1)
{
	return soap_instantiate___qhjkdsf__dsf(soap, n, NULL, NULL, NULL);
}

inline struct __qhjkdsf__dsf * soap_new_req___qhjkdsf__dsf(
	struct soap *soap)
{
	struct __qhjkdsf__dsf *_p = soap_new___qhjkdsf__dsf(soap);
	if (_p)
	{	soap_default___qhjkdsf__dsf(soap, _p);
	}
	return _p;
}

inline struct __qhjkdsf__dsf * soap_new_set___qhjkdsf__dsf(
	struct soap *soap,
	qhjkdsf__requestBody *reqBody)
{
	struct __qhjkdsf__dsf *_p = soap_new___qhjkdsf__dsf(soap);
	if (_p)
	{	soap_default___qhjkdsf__dsf(soap, _p);
		_p->reqBody = reqBody;
	}
	return _p;
}
SOAP_FMAC3 int SOAP_FMAC4 soap_put___qhjkdsf__dsf(struct soap*, const struct __qhjkdsf__dsf *, const char*, const char*);

inline int soap_write___qhjkdsf__dsf(struct soap *soap, struct __qhjkdsf__dsf const*p)
{
	soap_free_temp(soap);
	if (soap_begin_send(soap) || (soap_serialize___qhjkdsf__dsf(soap, p), 0) || soap_put___qhjkdsf__dsf(soap, p, "-qhjkdsf:dsf", "") || soap_end_send(soap))
			return soap->error;
	return SOAP_OK;
}

inline int soap_PUT___qhjkdsf__dsf(struct soap *soap, const char *URL, struct __qhjkdsf__dsf const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || (soap_serialize___qhjkdsf__dsf(soap, p), 0) || soap_put___qhjkdsf__dsf(soap, p, "-qhjkdsf:dsf", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send___qhjkdsf__dsf(struct soap *soap, const char *URL, struct __qhjkdsf__dsf const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || (soap_serialize___qhjkdsf__dsf(soap, p), 0) || soap_put___qhjkdsf__dsf(soap, p, "-qhjkdsf:dsf", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 struct __qhjkdsf__dsf * SOAP_FMAC4 soap_get___qhjkdsf__dsf(struct soap*, struct __qhjkdsf__dsf *, const char*, const char*);

inline int soap_read___qhjkdsf__dsf(struct soap *soap, struct __qhjkdsf__dsf *p)
{
	if (p)
	{	soap_default___qhjkdsf__dsf(soap, p);
		if (soap_begin_recv(soap) || soap_get___qhjkdsf__dsf(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET___qhjkdsf__dsf(struct soap *soap, const char *URL, struct __qhjkdsf__dsf *p)
{
	if (soap_GET(soap, URL, NULL) || soap_read___qhjkdsf__dsf(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv___qhjkdsf__dsf(struct soap *soap, struct __qhjkdsf__dsf *p)
{
	if (soap_read___qhjkdsf__dsf(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Reason_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap*, const char *, int, struct SOAP_ENV__Reason *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap*, const char*, struct SOAP_ENV__Reason **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap*, struct SOAP_ENV__Reason **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Detail_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap*, const char *, int, struct SOAP_ENV__Detail *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap*, const char*, struct SOAP_ENV__Detail **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap*, struct SOAP_ENV__Detail **, const char*, const char*);
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
#define SOAP_TYPE_PointerToSOAP_ENV__Code_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap*, const char *, int, struct SOAP_ENV__Code *const*, const char *);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap*, const char*, struct SOAP_ENV__Code **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code *const*, const char*, const char*);
SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap*, struct SOAP_ENV__Code **, const char*, const char*);
#endif

#endif

#ifndef SOAP_TYPE_PointerToqhjkdsf__requestBody_DEFINED
#define SOAP_TYPE_PointerToqhjkdsf__requestBody_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToqhjkdsf__requestBody(struct soap*, qhjkdsf__requestBody *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToqhjkdsf__requestBody(struct soap*, const char *, int, qhjkdsf__requestBody *const*, const char *);
SOAP_FMAC3 qhjkdsf__requestBody ** SOAP_FMAC4 soap_in_PointerToqhjkdsf__requestBody(struct soap*, const char*, qhjkdsf__requestBody **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToqhjkdsf__requestBody(struct soap*, qhjkdsf__requestBody *const*, const char*, const char*);
SOAP_FMAC3 qhjkdsf__requestBody ** SOAP_FMAC4 soap_get_PointerToqhjkdsf__requestBody(struct soap*, qhjkdsf__requestBody **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__Max127Text_DEFINED
#define SOAP_TYPE_PointerToxsd__Max127Text_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__Max127Text(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__Max127Text(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__Max127Text(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__Max127Text(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__Max127Text(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE_PointerToxsd__ReturnEncrypt_DEFINED
#define SOAP_TYPE_PointerToxsd__ReturnEncrypt_DEFINED
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__ReturnEncrypt(struct soap*, std::string *const*);
SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__ReturnEncrypt(struct soap*, const char *, int, std::string *const*, const char *);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__ReturnEncrypt(struct soap*, const char*, std::string **, const char*);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__ReturnEncrypt(struct soap*, std::string *const*, const char*, const char*);
SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__ReturnEncrypt(struct soap*, std::string **, const char*, const char*);
#endif

#ifndef SOAP_TYPE__XML_DEFINED
#define SOAP_TYPE__XML_DEFINED
#endif

#ifndef SOAP_TYPE__QName_DEFINED
#define SOAP_TYPE__QName_DEFINED

inline void soap_default__QName(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap*, char *const*);

#define soap__QName2s(soap, a) soap_QName2s(soap, (a))
SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2_QName(soap, s, a) soap_s2QName((soap), (s), (char**)(a), 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap*, const char*, char **, const char*);

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new__QName(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap*, char *const*, const char*, const char*);

inline int soap_write__QName(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put__QName(soap, p, "QName", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put__QName(soap, p, "QName", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send__QName(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put__QName(soap, p, "QName", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap*, char **, const char*, const char*);

inline int soap_read__QName(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get__QName(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET__QName(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || soap_read__QName(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv__QName(struct soap *soap, char **p)
{
	if (soap_read__QName(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#ifndef SOAP_TYPE_string_DEFINED
#define SOAP_TYPE_string_DEFINED

inline void soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}
SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap*, char *const*);

#define soap_string2s(soap, a) (a)
SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap*, const char*, int, char*const*, const char*);

#define soap_s2string(soap, s, a) soap_s2char((soap), (s), (char**)(a), 0, -1, NULL)
SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap*, const char*, char **, const char*);

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n = -1);
SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap*, char *const*, const char*, const char*);

inline int soap_write_string(struct soap *soap, char *const*p)
{
	soap_free_temp(soap);
	if (p)
	{	if (soap_begin_send(soap) || soap_put_string(soap, p, "string", "") || soap_end_send(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_PUT_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_PUT(soap, URL, NULL, NULL) || soap_put_string(soap, p, "string", "") || soap_end_send(soap) || soap_recv_empty_response(soap))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_send_string(struct soap *soap, const char *URL, char *const*p)
{
	soap_free_temp(soap);
	if (soap_connect(soap, URL, NULL) || soap_put_string(soap, p, "string", "") || soap_end_send(soap))
		return soap->error;
	return SOAP_OK;
}
SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap*, char **, const char*, const char*);

inline int soap_read_string(struct soap *soap, char **p)
{
	if (p)
	{	if (soap_begin_recv(soap) || soap_get_string(soap, p, NULL, NULL) == NULL || soap_end_recv(soap))
			return soap->error;
	}
	return SOAP_OK;
}

inline int soap_GET_string(struct soap *soap, const char *URL, char **p)
{
	if (soap_GET(soap, URL, NULL) || soap_read_string(soap, p))
		return soap->error;
	return SOAP_OK;
}

inline int soap_POST_recv_string(struct soap *soap, char **p)
{
	if (soap_read_string(soap, p) || soap_closesock(soap))
		return soap->error;
	return SOAP_OK;
}
#endif

#endif

/* End of soapH.h */
